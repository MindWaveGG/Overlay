<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goal Tracker</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
</head>
<body>
   <canvas id="goalCanvas" width="600" height="600"></canvas>
<p id="targetDateDisplay"></p>
<p id="errorMessage" style="color:red;"></p>

<script>
    let canvas, ctx;
    let centerX, centerY, cameraRadius = 100;
    let baseRadius = 120, donutWidth = 20, donutSpacing = 10;
    let targetDate = new Date();
    let followerCurrent = 0, followerGoal = 100;
    let subCurrent = 0, subGoal = 20;
    let bitsCurrent = 0, bitsGoal = 1000;
    let donationCurrent = 0, donationGoal = 100;
    let cameraImage = new Image();
    cameraImage.src = 'your-image-url.png'; // Replace with actual image URL

    async function fetchData(url, fallbackType = null) {
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error("Network error");
            return await response.json();
        } catch (error) {
            console.error("Fetch error:", error);
            document.getElementById("errorMessage").textContent = "Failed to load data. Using fallback values.";
            return getRevertData(fallbackType);
        }
    }

    function getRevertData(type) {
        const fallbackData = {
            timer: { startTime: new Date().toISOString(), endTime: new Date(Date.now() + 3600000).toISOString() },
            "Follower Goal": { CurrentValue: 50, goalValue: 100 },
            "Subscription Goal": { CurrentValue: 10, goalValue: 20 },
            "Bits Goal": { CurrentValue: 500, goalValue: 1000 },
            "Donation Goal": { CurrentValue: 20, goalValue: 100 },
        };
        return fallbackData[type] || null;
    }

    async function loadInitialData() {
        let timerData = await fetchData("https://script.google.com/macros/s/...", "timer");
        if (!timerData) return;

        targetDate = new Date(timerData.endTime);
        document.getElementById("targetDateDisplay").textContent = `Target Date: ${targetDate.toDateString()} ${targetDate.toLocaleTimeString()}`;

        await fetchAllGoalData();
    }

    async function fetchAllGoalData() {
        const goalTypes = ["Follower Goal", "Subscription Goal", "Bits Goal", "Donation Goal"];
        await Promise.all(goalTypes.map(goalType => fetchGoalData(goalType)));
    }

    async function fetchGoalData(goalType) {
        const url = `https://script.google.com/macros/s/...&goalType=${encodeURIComponent(goalType)}`;
        const goalData = await fetchData(url, goalType);
        if (!goalData) return;

        if (goalType === "Follower Goal") { followerCurrent = goalData.CurrentValue; followerGoal = goalData.goalValue; }
        else if (goalType === "Subscription Goal") { subCurrent = goalData.CurrentValue; subGoal = goalData.goalValue; }
        else if (goalType === "Bits Goal") { bitsCurrent = goalData.CurrentValue; bitsGoal = goalData.goalValue; }
        else if (goalType === "Donation Goal") { donationCurrent = goalData.CurrentValue; donationGoal = goalData.goalValue; }
    }

    function getTimeRemaining() {
        let now = new Date();
        let timeDiff = targetDate - now;
        if (timeDiff < 0) timeDiff = 0;

        let days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
        let hours = Math.floor((timeDiff / (1000 * 60 * 60)) % 24);
        let minutes = Math.floor((timeDiff / (1000 * 60)) % 60);
        let seconds = Math.floor((timeDiff / 1000) % 60);
        let percentage = 1 - timeDiff / (targetDate - new Date(targetDate - 3600000 * 24));

        return { countdownDays: days, countdownHours: hours, countdownMinutes: minutes, countdownSeconds: seconds, percentage };
    }

    function drawCameraCircle(x, y, radius, opacity) {
        ctx.globalAlpha = opacity;
        ctx.drawImage(cameraImage, x - radius, y - radius, radius * 2, radius * 2);
        ctx.globalAlpha = 1.0;
    }

    function drawDonut(x, y, radius, width, percentage, color) {
        if (isNaN(percentage) || percentage < 0) percentage = 0;

        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2 * percentage, false);
        ctx.lineWidth = width;
        ctx.strokeStyle = color;
        ctx.stroke();
    }

    function drawLabelWithLine(label, x, y, radius, percentage, index, totalItems, lineColor, textColor) {
        let angle = Math.PI * 2 * percentage;
        let labelX = x + Math.cos(angle) * (radius + 20);
        let labelY = y + Math.sin(angle) * (radius + 20);

        ctx.beginPath();
        ctx.moveTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
        ctx.lineTo(labelX, labelY);
        ctx.strokeStyle = lineColor;
        ctx.stroke();

        ctx.font = "12px Arial";
        ctx.fillStyle = textColor;
        ctx.fillText(label, labelX + 5, labelY);
    }

    function drawAll() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawCameraCircle(centerX, centerY, cameraRadius + 20, .13);

        const { countdownDays, countdownHours, countdownMinutes, countdownSeconds, percentage } = getTimeRemaining();
        const countdownText = `Retires In: ${countdownDays}d ${countdownHours}h ${countdownMinutes}m ${countdownSeconds}s`;

        let data = [
            { label: countdownText, percentage: percentage, color: 'red' },
            { label: `Followers: ${followerCurrent}/${followerGoal}`, percentage: followerCurrent / Math.max(followerGoal, 1), color: 'red' },
            { label: `Subs: ${subCurrent}/${subGoal}`, percentage: subCurrent / Math.max(subGoal, 1), color: 'red' },
            { label: `Donations: $${donationCurrent}/$${donationGoal}`, percentage: donationCurrent / Math.max(donationGoal, 1), color: 'red' },
            { label: `Bits: ${bitsCurrent}/${bitsGoal}`, percentage: bitsCurrent / Math.max(bitsGoal, 1), color: 'red' }
        ];

        data.sort((a, b) => b.percentage - a.percentage);

        data.forEach((item, index) => {
            drawDonut(centerX, centerY, baseRadius + index * (donutWidth + donutSpacing), donutWidth, item.percentage, item.color);
            drawLabelWithLine(item.label, centerX, centerY, baseRadius + index * (donutWidth + donutSpacing), item.percentage, index, data.length, 'black', 'black');
        });

        requestAnimationFrame(drawAll);
    }

    function setupCanvas() {
        canvas = document.getElementById("goalCanvas");
        ctx = canvas.getContext("2d");
        centerX = canvas.width / 2;
        centerY = canvas.height / 2;

        cameraImage.onload = () => {
            loadInitialData();
            requestAnimationFrame(drawAll);
        };
    }

    window.onload = setupCanvas;
</script>
</body>
</html>
