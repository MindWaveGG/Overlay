<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goal Tracker</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
</head>
<body>
   <canvas id="goalCanvas" width="600" height="600"></canvas>
<p id="targetDateDisplay"></p>
<p id="errorMessage" style="color:red;"></p>

<script>
    let canvas, ctx;
    let centerX, centerY, cameraRadius = 100;
    let baseRadius = 120, donutWidth = 20, donutSpacing = 10;
    let targetDate = new Date();
    let followerCurrent = 0, followerGoal = 100;
    let subCurrent = 0, subGoal = 20;
    let bitsCurrent = 0, bitsGoal = 1000;
    let donationCurrent = 0, donationGoal = 100;
    let cameraImage = new Image();
    cameraImage.src = 'your-image-url.png'; // Replace with actual image URL

    async function fetchData(url, fallbackType = null) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error("Network error");
        return await response.json();
    } catch (error) {
        console.error("Fetch error:", error);
        document.getElementById("errorMessage").textContent = "Failed to load data. Using fallback values.";
        return getRevertData(fallbackType);
    }
}

function getRevertData(type) {
    const fallbackData = {
        timer: { startTime: new Date().toISOString(), endTime: new Date(Date.now() + 3600000).toISOString() },
        "Follower Goal": { CurrentValue: 50, goalValue: 100 },
        "Subscription Goal": { CurrentValue: 10, goalValue: 20 },
        "Bits Goal": { CurrentValue: 500, goalValue: 1000 },
        "Donation Goal": { CurrentValue: 20, goalValue: 100 },
    };
    return fallbackData[type] || null;
}

// ✅ Ensure drawAll() starts even if Google Script fails
async function loadInitialData() {
    let timerData = await fetchData("https://script.google.com/macros/s/...", "timer");
    if (!timerData) return;

    targetDate = new Date(timerData.endTime);
    document.getElementById("targetDateDisplay").textContent = `Target Date: ${targetDate.toDateString()} ${targetDate.toLocaleTimeString()}`;

    await fetchAllGoalData();
}

// ✅ Ensure drawAll() starts after data is loaded
async function fetchAllGoalData() {
    const goalTypes = ["Follower Goal", "Subscription Goal", "Bits Goal", "Donation Goal"];
    await Promise.all(goalTypes.map(goalType => fetchGoalData(goalType)));
    
    // Draw only after all data is set
    requestAnimationFrame(drawAll);
}

async function fetchGoalData(goalType) {
    const url = `https://script.google.com/macros/s/AKfycby4UKXfW68KHrWyGoRUpuPnUcTk2Eu2SyLxm3XrcYPX7qwtlWG6I02WWrckkbAgI3Af/exec&action=getGoal&goalType=${encodeURIComponent(goalType)}`;
    const goalData = await fetchData(url, goalType);

    if (!goalData) return;

    // ✅ Apply fallback data to global variables
    if (goalType === "Follower Goal") {
        followerCurrent = goalData.CurrentValue || 0;
        followerGoal = goalData.goalValue || 1;
    } else if (goalType === "Subscription Goal") {
        subCurrent = goalData.CurrentValue || 0;
        subGoal = goalData.goalValue || 1;
    } else if (goalType === "Bits Goal") {
        bitsCurrent = goalData.CurrentValue || 0;
        bitsGoal = goalData.goalValue || 1;
    } else if (goalType === "Donation Goal") {
        donationCurrent = goalData.CurrentValue || 0;
        donationGoal = goalData.goalValue || 1;
    }
}

    function getTimeRemaining() {
        let now = new Date();
        let timeDiff = targetDate - now;
        if (timeDiff < 0) timeDiff = 0;

        let days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
        let hours = Math.floor((timeDiff / (1000 * 60 * 60)) % 24);
        let minutes = Math.floor((timeDiff / (1000 * 60)) % 60);
        let seconds = Math.floor((timeDiff / 1000) % 60);
        let percentage = 1 - timeDiff / (targetDate - new Date(targetDate - 3600000 * 24));

        return { countdownDays: days, countdownHours: hours, countdownMinutes: minutes, countdownSeconds: seconds, percentage };
    }

    function drawCameraCircle(x, y, radius, opacity) {
        ctx.globalAlpha = opacity;
        ctx.drawImage(cameraImage, x - radius, y - radius, radius * 2, radius * 2);
        ctx.globalAlpha = 1.0;
    }

    function drawDonut(x, y, radius, width, percentage, color) {
        if (isNaN(percentage) || percentage < 0) percentage = 0;

        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2 * percentage, false);
        ctx.lineWidth = width;
        ctx.strokeStyle = color;
        ctx.stroke();
    }

    function drawLabelWithLine(label, x, y, radius, percentage, index, totalItems, lineColor, textColor) {
        let angle = Math.PI * 2 * percentage;
        let labelX = x + Math.cos(angle) * (radius + 20);
        let labelY = y + Math.sin(angle) * (radius + 20);

        ctx.beginPath();
        ctx.moveTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
        ctx.lineTo(labelX, labelY);
        ctx.strokeStyle = lineColor;
        ctx.stroke();

        ctx.font = "12px Arial";
        ctx.fillStyle = textColor;
        ctx.fillText(label, labelX + 5, labelY);
    }

    function drawAll() {
        console.log("drawAll is running!");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawCameraCircle(centerX, centerY, cameraRadius + 20, .13);

        const { countdownDays, countdownHours, countdownMinutes, countdownSeconds, percentage } = getTimeRemaining();
        const countdownText = `Retires In: ${countdownDays}d ${countdownHours}h ${countdownMinutes}m ${countdownSeconds}s`;

        let data = [
            { label: countdownText, percentage: percentage, color: 'red' },
            { label: `Followers: ${followerCurrent}/${followerGoal}`, percentage: followerCurrent / Math.max(followerGoal, 1), color: 'red' },
            { label: `Subs: ${subCurrent}/${subGoal}`, percentage: subCurrent / Math.max(subGoal, 1), color: 'red' },
            { label: `Donations: $${donationCurrent}/$${donationGoal}`, percentage: donationCurrent / Math.max(donationGoal, 1), color: 'red' },
            { label: `Bits: ${bitsCurrent}/${bitsGoal}`, percentage: bitsCurrent / Math.max(bitsGoal, 1), color: 'red' }
        ];

        data.sort((a, b) => b.percentage - a.percentage);

        data.forEach((item, index) => {
            drawDonut(centerX, centerY, baseRadius + index * (donutWidth + donutSpacing), donutWidth, item.percentage, item.color);
            drawLabelWithLine(item.label, centerX, centerY, baseRadius + index * (donutWidth + donutSpacing), item.percentage, index, data.length, 'black', 'black');
        });

        requestAnimationFrame(drawAll);
    }

function setupCanvas() {
    canvas = document.getElementById("goalCanvas");
    ctx = canvas.getContext("2d");
    centerX = canvas.width / 2;
    centerY = canvas.height / 2;

    cameraImage.onload = () => {
        loadInitialData(); // ✅ Start loading data
    };
if (!canvas || !ctx) {
    console.error("Canvas or context not found!");
}
    cameraImage.src = 'https://static-cdn.jtvnw.net/jtv_user_pictures/4ae8547d-3e84-47bd-a024-ba09885f1bbe-profile_image-300x300.png'; // Replace with actual image URL
}

window.onload = setupCanvas;
</script>
</body>
</html>
