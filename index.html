<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goal Tracker</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
</head>
<body>
   <canvas id="goalCanvas" width="600" height="600"></canvas>
<p id="targetDateDisplay"></p>
<p id="errorMessage" style="color:red;"></p>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const canvasSize = 2200;
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const donutWidth = 40;
    const donutSpacing = 15;
    const cameraRadius = 670;
    const baseRadius = cameraRadius + donutSpacing + donutWidth;
    let targetDate = new Date();
    let followerCurrent = 0, followerGoal = 100;
    let subCurrent = 0, subGoal = 20;
    let bitsCurrent = 0, bitsGoal = 1000;
    let donationCurrent = 0, donationGoal = 100;
    const cameraImage = new Image();
    cameraImage.src = 'https://static-cdn.jtvnw.net/jtv_user_pictures/4ae8547d-3e84-47bd-a024-ba09885f1bbe-profile_image-300x300.png';
    
    async function fetchData(url, fallbackType = null) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error("Network error");
        return await response.json();
    } catch (error) {
        console.error("Fetch error:", error);
        document.getElementById("errorMessage").textContent = "Failed to load data. Using fallback values.";
        return getRevertData(fallbackType);
    }
}

function getRevertData(type) {
    const fallbackData = {
        timer: { startTime: new Date().toISOString(), endTime: new Date(Date.now() + 3600000).toISOString() },
        "Follower Goal": { CurrentValue: 50, goalValue: 100 },
        "Subscription Goal": { CurrentValue: 10, goalValue: 20 },
        "Bits Goal": { CurrentValue: 500, goalValue: 1000 },
        "Donation Goal": { CurrentValue: 20, goalValue: 100 },
    };
    return fallbackData[type] || null;
}

// ✅ Ensure drawAll() starts even if Google Script fails
async function loadInitialData() {
    let timerData = await fetchData("https://script.google.com/macros/s/...", "timer");
    if (!timerData) return;

    targetDate = new Date(timerData.endTime);
    document.getElementById("targetDateDisplay").textContent = `Target Date: ${targetDate.toDateString()} ${targetDate.toLocaleTimeString()}`;

    await fetchAllGoalData();
}

// ✅ Ensure drawAll() starts after data is loaded
async function fetchAllGoalData() {
    const goalTypes = ["Follower Goal", "Subscription Goal", "Bits Goal", "Donation Goal"];
    await Promise.all(goalTypes.map(goalType => fetchGoalData(goalType)));
    
    // Draw only after all data is set
    requestAnimationFrame(drawAll);
}

async function fetchGoalData(goalType) {
    const url = `https://script.google.com/macros/s/AKfycby4UKXfW68KHrWyGoRUpuPnUcTk2Eu2SyLxm3XrcYPX7qwtlWG6I02WWrckkbAgI3Af/exec&action=getGoal&goalType=${encodeURIComponent(goalType)}`;
    const goalData = await fetchData(url, goalType);

    if (!goalData) return;

    // ✅ Apply fallback data to global variables
    if (goalType === "Follower Goal") {
        followerCurrent = goalData.CurrentValue || 0;
        followerGoal = goalData.goalValue || 1;
    } else if (goalType === "Subscription Goal") {
        subCurrent = goalData.CurrentValue || 0;
        subGoal = goalData.goalValue || 1;
    } else if (goalType === "Bits Goal") {
        bitsCurrent = goalData.CurrentValue || 0;
        bitsGoal = goalData.goalValue || 1;
    } else if (goalType === "Donation Goal") {
        donationCurrent = goalData.CurrentValue || 0;
        donationGoal = goalData.goalValue || 1;
    }
}

    function getTimeRemaining() {
        let now = new Date();
        let timeDiff = targetDate - now;
        if (timeDiff < 0) timeDiff = 0;

        let days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
        let hours = Math.floor((timeDiff / (1000 * 60 * 60)) % 24);
        let minutes = Math.floor((timeDiff / (1000 * 60)) % 60);
        let seconds = Math.floor((timeDiff / 1000) % 60);
        let percentage = 1 - timeDiff / (targetDate - new Date(targetDate - 3600000 * 24));

        return { countdownDays: days, countdownHours: hours, countdownMinutes: minutes, countdownSeconds: seconds, percentage };
    }

function drawCameraCircle(x, y, radius, transparency) {
    ctx.save();
    ctx.globalAlpha = transparency;

    // Draw the image as a circular clip
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.clip();
    ctx.drawImage(cameraImage, x - radius, y - radius, radius * 2, radius * 2);

    ctx.restore(); // Restore state to avoid clipping affecting stroke

    // Draw the border
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.lineWidth = 8;
    ctx.strokeStyle = 'red';
    ctx.stroke();
}

function drawDonut(x, y, radius, width, percentage, color) {
            const endAngle = Math.PI * 2 * percentage - Math.PI / 2;
            if (percentage > 0) {
                ctx.beginPath();
                ctx.arc(x, y, radius, -Math.PI / 2, endAngle);
                ctx.lineWidth = width;
                ctx.strokeStyle = color;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(x, y, radius + width / 2, -Math.PI / 2, endAngle);
                ctx.lineWidth = 5;
		ctx.lineColor = '#ffffffff';
                ctx.strokeStyle = 'black';
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(x, y, radius - width / 2, -Math.PI / 2, endAngle);
                ctx.lineWidth = 5;
		ctx.lineColor = '#000000';
                ctx.strokeStyle = 'black';
                ctx.stroke();
               
            }
        }

unction drawLabelWithLine(label, x, y, radius, percentage, labelIndex, totalLabels, textColor, lineColor, borderColor) {
            const padding = 10;
            const fontSize = 80;
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.fillStyle = textColor;

            const textWidth = ctx.measureText(label).width;
            const labelWidth = textWidth + padding * 2;
            const labelHeight = fontSize + padding * 2;

            const reversedIndex = totalLabels - labelIndex - 1;
            const labelX = 100;
            const labelY = 100 + reversedIndex * (labelHeight + 10);

            const angle = (-Math.PI / 2) + (Math.PI * 2 * percentage);
            const startX = x + radius * Math.cos(angle);
            const startY = y + radius * Math.sin(angle);
		// 🖋️ Draw the label border
		ctx.strokeStyle = borderColor;
		ctx.lineWidth = 10;
		ctx.strokeRect(labelX, labelY, labelWidth, labelHeight);
		// 🎯 Draw the line first so it's behind the label
		ctx.beginPath();
		ctx.moveTo(startX, startY);
		ctx.lineTo(labelX + labelWidth, labelY + labelHeight / 2);
		ctx.strokeStyle = 'white';
		ctx.lineWidth = 10;
		ctx.stroke();
		// 🖼️ Draw the label background
		ctx.fillStyle = '#0000007F';
		//ctx.globalAlpha = .5;
		ctx.fillRect(labelX, labelY, labelWidth, labelHeight);
		 // 📝 Draw the label text
		ctx.fillStyle = textColor;
		ctx.textAlign = "left";
		ctx.fillText(label, labelX + padding, labelY + fontSize + padding / 2);
        }

    function drawAll() {function drawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawCameraCircle(centerX, centerY, cameraRadius + 20, .13);

            const { countdownDays, countdownHours, countdownMinutes, countdownSeconds, percentage } = getTimeRemaining();
            const countdownText = `Retires In: ${countdownDays}d ${countdownHours}h ${countdownMinutes}m ${countdownSeconds}s`;

            let data = [
                { label: countdownText, percentage: percentage, color: 'red' },
                { label: `Followers: ${followerCurrent}/${followerGoal}`, percentage: followerCurrent / followerGoal, color: 'red' },
                { label: `Subs: ${subCurrent}/${subGoal}`, percentage: subCurrent / subGoal, color: 'red' },
                { label: `Donations: $${donationCurrent}/$${donationGoal}`, percentage: donationCurrent / donationGoal, color: 'red' },
                { label: `Bits: ${bitsCurrent}/${bitsGoal}`, percentage: bitsCurrent / bitsGoal, color: 'red' }
            ];

            data.sort((a, b) => b.percentage - a.percentage);

            data.forEach((item, index) => {
                drawDonut(centerX, centerY, baseRadius + index * (donutWidth + donutSpacing), donutWidth, item.percentage, item.color);
                drawLabelWithLine(item.label, centerX, centerY, baseRadius + index * (donutWidth + donutSpacing), item.percentage, index, data.length, 'red', 'black', 'black');
            });

            requestAnimationFrame(drawAll);
        }

function setupCanvas() {
    canvas = document.getElementById("goalCanvas");
    ctx = canvas.getContext("2d");
    centerX = canvas.width / 2;
    centerY = canvas.height / 2;

    cameraImage.onload = () => {
        loadInitialData(); // ✅ Start loading data
    };
if (!canvas || !ctx) {
    console.error("Canvas or context not found!");
}
    cameraImage.src = 'https://static-cdn.jtvnw.net/jtv_user_pictures/4ae8547d-3e84-47bd-a024-ba09885f1bbe-profile_image-300x300.png'; // Replace with actual image URL
}

window.onload = setupCanvas;
</script>
</body>
</html>
