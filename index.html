<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goal Tracker</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
</head>
<body>
    <p id="countdownTimer"></p>
    <p id="targetDateDisplay"></p>
    <p id="errorMessage" style="color:red;"></p>
    <script>
        let canvas, ctx;
    let centerX, centerY, cameraRadius = 100;
    let baseRadius = 120, donutWidth = 20, donutSpacing = 10;
    let targetDate = new Date();
    let followerCurrent = 0, followerGoal = 100;
    let subCurrent = 0, subGoal = 20;
    let bitsCurrent = 0, bitsGoal = 1000;
    let donationCurrent = 0, donationGoal = 100;
    
    async function fetchData(url, fallbackType = null) {
        try {
            console.log(`Fetching data from: ${url}`);
            const response = await fetch(url);
            if (!response.ok) throw new Error("Network error");
            return await response.json();
        } catch (error) {
            console.error("Fetch error:", error);
            document.getElementById("errorMessage").textContent = "Failed to load data. Using fallback values.";
            return getRevertData(fallbackType);
        }
    }

    function getRevertData(type) {
        console.warn(`Using fallback data for: ${type}`);
        const fallbackData = {
            timer: { startTime: new Date().toISOString(), endTime: new Date(Date.now() + 3600000).toISOString() },
            "Follower Goal": { CurrentValue: 50, goalValue: 100 },
            "Subscription Goal": { CurrentValue: 10, goalValue: 20 },
            "Bits Goal": { CurrentValue: 500, goalValue: 1000 },
            "Donation Goal": { CurrentValue: 20, goalValue: 100 },
        };
        return fallbackData[type] || null;
    }

    async function loadInitialData() {
        console.log("Loading initial data...");
        let timerData = await fetchData("https://script.google.com/macros/s/...", "timer");

        if (!timerData) {
            console.warn("Failed to fetch timer data.");
            return;
        }

        targetDate = new Date(timerData.endTime);
        document.getElementById("targetDateDisplay").textContent = `Target Date: ${targetDate.toDateString()} ${targetDate.toLocaleTimeString()}`;

        await fetchAllGoalData();
    }

    async function fetchAllGoalData() {
        const goalTypes = ["Follower Goal", "Subscription Goal", "Bits Goal", "Donation Goal"];
        await Promise.all(goalTypes.map(goalType => fetchGoalData(goalType)));
    }

    async function fetchGoalData(goalType) {
        const url = `https://script.google.com/macros/s/...&goalType=${encodeURIComponent(goalType)}`;
        const goalData = await fetchData(url, goalType);
        if (!goalData) return;

        if (goalType === "Follower Goal") { followerCurrent = goalData.CurrentValue; followerGoal = goalData.goalValue; }
        else if (goalType === "Subscription Goal") { subCurrent = goalData.CurrentValue; subGoal = goalData.goalValue; }
        else if (goalType === "Bits Goal") { bitsCurrent = goalData.CurrentValue; bitsGoal = goalData.goalValue; }
        else if (goalType === "Donation Goal") { donationCurrent = goalData.CurrentValue; donationGoal = goalData.goalValue; }
    }

    function getTimeRemaining() {
        let now = new Date();
        let timeDiff = targetDate - now;
        if (timeDiff < 0) timeDiff = 0;

        let days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
        let hours = Math.floor((timeDiff / (1000 * 60 * 60)) % 24);
        let minutes = Math.floor((timeDiff / (1000 * 60)) % 60);
        let seconds = Math.floor((timeDiff / 1000) % 60);
        let percentage = 1 - timeDiff / (targetDate - new Date(targetDate - 3600000 * 24));

        return { countdownDays: days, countdownHours: hours, countdownMinutes: minutes, countdownSeconds: seconds, percentage };
    }

    function drawAll() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawCameraCircle(centerX, centerY, cameraRadius + 20, .13);

        const { countdownDays, countdownHours, countdownMinutes, countdownSeconds, percentage } = getTimeRemaining();
        const countdownText = `Retires In: ${countdownDays}d ${countdownHours}h ${countdownMinutes}m ${countdownSeconds}s`;

        let data = [
            { label: countdownText, percentage: percentage, color: 'red' },
            { label: `Followers: ${followerCurrent}/${followerGoal}`, percentage: followerCurrent / followerGoal, color: 'red' },
            { label: `Subs: ${subCurrent}/${subGoal}`, percentage: subCurrent / subGoal, color: 'red' },
            { label: `Donations: $${donationCurrent}/$${donationGoal}`, percentage: donationCurrent / donationGoal, color: 'red' },
            { label: `Bits: ${bitsCurrent}/${bitsGoal}`, percentage: bitsCurrent / bitsGoal, color: 'red' }
        ];

        data.sort((a, b) => b.percentage - a.percentage);

        data.forEach((item, index) => {
            drawDonut(centerX, centerY, baseRadius + index * (donutWidth + donutSpacing), donutWidth, item.percentage, item.color);
            drawLabelWithLine(item.label, centerX, centerY, baseRadius + index * (donutWidth + donutSpacing), item.percentage, index, data.length, 'red', 'black', 'black');
        });

        requestAnimationFrame(drawAll);
    }

    function setupCanvas() {
        canvas = document.getElementById("goalCanvas");
        if (!canvas) {
            console.error("Canvas element not found!");
            return;
        }
        ctx = canvas.getContext("2d");
        centerX = canvas.width / 2;
        centerY = canvas.height / 2;

        loadInitialData();
        requestAnimationFrame(drawAll);
    }

    window.onload = setupCanvas;
    </script>
</body>
</html>
