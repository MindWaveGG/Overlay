<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goal Tracker</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
</head>
<body>
    <canvas id="myCanvas"></canvas>
    <p id="countdownTimer"></p>
    <p id="targetDateDisplay"></p>
    <p id="errorMessage" style="color:red;"></p>
    <script>
        let initiationComplete = false;
        let targetDate = 0, startTime, endTime;
        let timerChart = null;
        const goalCharts = {};
        let followerCurrent = 0, followerGoal = 0;
        let subCurrent = 0, subGoal = 0;
        let donationCurrent = 0, donationGoal = 0;
        let bitsCurrent = 0, bitsGoal = 0;

        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 2200;
        canvas.height = 2200;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const cameraRadius = 670;

        const cameraImage = new Image();
        cameraImage.src = 'https://static-cdn.jtvnw.net/jtv_user_pictures/4ae8547d-3e84-47bd-a024-ba09885f1bbe-profile_image-300x300.png';

        cameraImage.onload = () => drawAll(); // Ensure the image is loaded before drawing

    async function fetchData(url, fallbackType = null) {
        try {
            console.log(`Fetching data from: ${url}`);
            const response = await fetch(url);
            if (!response.ok) throw new Error("Network error");
            return await response.json();
        } catch (error) {
            console.error("Fetch error:", error);
            document.getElementById("errorMessage").textContent = "Failed to load data. Using fallback values.";
            return getRevertData(fallbackType);
        }
    }

    function getRevertData(type) {
        console.warn(`Using fallback data for: ${type}`);
        const fallbackData = {
            timer: {
                startTime: new Date().toISOString(),
                endTime: new Date(Date.now() + 3600000).toISOString(), // 1 hour later
            },
            "Follower Goal": { CurrentValue: 50, goalValue: 100 },
            "Subscription Goal": { CurrentValue: 10, goalValue: 20 },
            "Bits Goal": { CurrentValue: 500, goalValue: 1000 },
            "Donation Goal": { CurrentValue: 20, goalValue: 100 },
        };
        return fallbackData[type] || null;
    }
        
      async function loadInitialData() {
        console.log("Loading initial data...");
        let timerData = await fetchData("https://script.google.com/macros/s/...", "timer");

        if (!timerData) {
            console.warn("Failed to fetch timer data.");
            return;
        }

        startTime = new Date(timerData.startTime);
        endTime = new Date(timerData.endTime);
        targetDate = endTime;

        const targetDateElement = document.getElementById("targetDateDisplay");
        if (targetDateElement) targetDateElement.textContent = `Target Date: ${endTime.toDateString()} ${endTime.toLocaleTimeString()}`;

        updateTimerChart();
        updateCountdown();
        await fetchAllGoalData();
        initiationComplete = true;
    }


        function updateCountdown() {
            const countdownElement = document.getElementById("countdownTimer");
            if (!countdownElement) return;

            const now = new Date();
            const timeRemaining = endTime - now;
            if (timeRemaining <= 0) {
                countdownElement.textContent = "Time's up!";
                return;
            }

            const days = Math.floor(timeRemaining / (1000 * 60 * 60 * 24));
            const hours = Math.floor((timeRemaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);
            countdownElement.textContent = `Countdown: ${days}d ${hours}h ${minutes}m ${seconds}s`;
        }

        function updateTimerChart() {
            const now = new Date();
            const elapsedTime = now - startTime;
            const totalTime = endTime - startTime;
            const progressPercentage = Math.min(100, (elapsedTime / totalTime) * 100);

            const ctx = document.getElementById("timerChart")?.getContext('2d');
            if (!ctx) return;

            if (!timerChart) {
                timerChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ["Progress", "Remaining"],
                        datasets: [{ data: [progressPercentage, 100 - progressPercentage], backgroundColor: ["#4caf50", "#ddd"] }]
                    },
                    options: { responsive: true, maintainAspectRatio: false }
                });
            } else {
                timerChart.data.datasets[0].data = [progressPercentage, 100 - progressPercentage];
                timerChart.update();
            }
        }

    async function fetchAllGoalData() {
        const goalTypes = ["Follower Goal", "Subscription Goal", "Bits Goal", "Donation Goal"];
        await Promise.all(goalTypes.map(goalType => fetchGoalData(goalType)));
    }

    async function fetchGoalData(goalType) {
        const url = `https://script.google.com/macros/s/...&goalType=${encodeURIComponent(goalType)}`;
        const goalData = await fetchData(url, goalType);
        if (!goalData) return;
        
        updateGoalChart(goalType, goalData.CurrentValue, goalData.goalValue);
    }

        function updateGoalChart(goalType, current, goal) {
            const chartId = {
                "Follower Goal": "followerChart",
                "Subscription Goal": "subscriptionChart",
                "Bits Goal": "bitsChart",
                "Donation Goal": "donationChart"
            }[goalType];

            const ctx = document.getElementById(chartId)?.getContext('2d');
            if (!ctx) return;

            const progress = Math.min(100, (current / goal) * 100);
            if (!goalCharts[goalType]) {
                goalCharts[goalType] = new Chart(ctx, {
                    type: 'doughnut',
                    data: { labels: ["Progress", "Remaining"], datasets: [{ data: [progress, 100 - progress], backgroundColor: ["#4caf50", "#ddd"] }] },
                    options: { responsive: true, maintainAspectRatio: false }
                });
            } else {
                goalCharts[goalType].data.datasets[0].data = [progress, 100 - progress];
                goalCharts[goalType].update();
            }
        }

        function drawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(cameraImage, centerX - cameraRadius, centerY - cameraRadius, cameraRadius * 2, cameraRadius * 2);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.arc(centerX, centerY, cameraRadius, 0, Math.PI * 2);
            ctx.stroke();
        }

        loadInitialData();
    </script>
</body>
</html>
