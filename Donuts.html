<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timer and Goal Tracker</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        h1 {
            text-align: center;
        }
        .container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
        }
        .chart-container {
            width: 300px;
            height: 300px;
            margin: 20px;
        }
        .stats {
            text-align: center;
            margin-top: 10px;
        }
        #countdownTimer {
            font-size: 1.5em;
            font-weight: bold;
        }
        #timerStats {
            font-size: 1.2em;
            margin-top: 10px;
        }
        #targetDateDisplay {
            font-size: 1.2em;
            margin-top: 10px;
        }
    </style>
</head>
<body>
<canvas id="myCanvas"></canvas>
<h1>Timer and Goal Tracker</h1>
<div id="errorMessage" style="color: red;"></div>

<!-- Timer Section -->
<div id="countdownTimer"></div>
<div id="timerStats"></div>
<div id="targetDateDisplay"></div>

<div class="container">
    <!-- Timer Chart -->
    <div class="chart-container">
        <canvas id="timerChart"></canvas>
    </div>

    <!-- Goal Charts -->
    <div class="chart-container">
        <canvas id="followerChart"></canvas>
        <div id="followerStats" class="stats"></div>
    </div>

    <div class="chart-container">
        <canvas id="subscriptionChart"></canvas>
        <div id="subscriptionStats" class="stats"></div>
    </div>

    <div class="chart-container">
        <canvas id="bitsChart"></canvas>
        <div id="bitsStats" class="stats"></div>
    </div>

    <div class="chart-container">
        <canvas id="donationChart"></canvas>
        <div id="donationStats" class="stats"></div>
    </div>
</div>

<script>
let initiationComplete = false;
let targetDate = 0;
let startTime, endTime;
let timerChart = null;
const goalCharts = {};

let followerCurrent = 0, followerGoal = 0;
let subCurrent = 0, subGoal = 0;
let donationCurrent = 0, donationGoal = 0;
let bitsCurrent = 0, bitsGoal = 0;

const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
const canvasSize = 2200;
canvas.width = canvasSize;
canvas.height = canvasSize;
const centerX = canvas.width / 2;
const centerY = canvas.height / 2;
const donutWidth = 40;
const donutSpacing = 15;
const cameraRadius = 670;
const baseRadius = cameraRadius + donutSpacing + donutWidth;

const cameraImage = new Image();
cameraImage.src = 'https://static-cdn.jtvnw.net/jtv_user_pictures/4ae8547d-3e84-47bd-a024-ba09885f1bbe-profile_image-300x300.png';

// Safe divide helper
function safePercent(current, goal) {
    return goal > 0 ? current / goal : 0;
}

// Fetch helper
async function fetchData(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error("Network error");
        return await response.json();
    } catch (error) {
        console.error("Fetch error:", error);
        document.getElementById("errorMessage").textContent = "Failed to load data. Retrying...";
        return null;
    }
}

// Load initial data
async function loadInitialData() {
    const timerData = await fetchData("https://script.google.com/macros/s/AKfycby4UKXfW68KHrWyGoRUpuPnUcTk2Eu2SyLxm3XrcYPX7qwtlWG6I02WWrckkbAgI3Af/exec?action=getTimer&timerName=Timer");

    if (timerData) {
        startTime = new Date(timerData.startTime);
        endTime = new Date(timerData.endTime);
        targetDate = endTime;
        document.getElementById("targetDateDisplay").textContent = `Target Date: ${endTime.toDateString()} ${endTime.toLocaleTimeString()}`;
        updateTimerChart();
        updateCountdown();
    }

    await fetchAllGoalData();
    initiationComplete = true;
}

// Countdown timer
function updateCountdown() {
    const countdownElement = document.getElementById("countdownTimer");
    const now = new Date();
    const timeRemaining = endTime - now;
    const days = Math.floor(timeRemaining / (1000 * 60 * 60 * 24));
    const hours = Math.floor((timeRemaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);
    countdownElement.textContent = timeRemaining > 0 ? `Countdown: ${days}d ${hours}h ${minutes}m ${seconds}s` : "Time's up!";
}

// Timer chart
function updateTimerChart() {
    const now = new Date();
    const progressPercentage = Math.min(100, ((now - startTime) / (endTime - startTime)) * 100);
    const ctx = document.getElementById("timerChart")?.getContext('2d');
    if (!ctx) return;

    if (!timerChart) {
        timerChart = new Chart(ctx, {
            type: 'doughnut',
            data: { labels: ["Progress","Remaining"], datasets:[{data:[progressPercentage,100-progressPercentage], backgroundColor:["#4caf50","#ddd"]}] },
            options: {
                responsive:true, maintainAspectRatio:false,
                plugins:{ datalabels:{
                    color:'white', font:{weight:'bold', size:14},
                    formatter: (value, context) => context.dataset.data[0] === value ? `${Math.round(progressPercentage)}%` : ''
                }}
            },
            plugins:[ChartDataLabels]
        });
    } else {
        timerChart.data.datasets[0].data = [progressPercentage, 100 - progressPercentage];
        timerChart.update();
    }

    document.getElementById("timerStats").textContent = `Timer Progress: ${Math.round(progressPercentage)}%`;
}

// Fetch all goals
async function fetchAllGoalData() {
    const goalTypes = ["Follower Goal","Subscription Goal","Bits Goal","Donation Goal"];
    await Promise.all(goalTypes.map(fetchGoalData));
}

// Fetch individual goal
async function fetchGoalData(goalType) {
    const url = `https://script.google.com/macros/s/AKfycby4UKXfW68KHrWyGoRUpuPnUcTk2Eu2SyLxm3XrcYPX7qwtlWG6I02WWrckkbAgI3Af/exec?action=getGoal&goalType=${encodeURIComponent(goalType)}`;
    const goalData = await fetchData(url);
    if (!goalData) return;

    const current = goalData.CurrentCount ?? 0;
    const goal = goalData.goalValue ?? 1;
    updateGoalChart(goalType, current, goal);
    updateGoalStats(goalType, current, goal);
}

// Update goal chart
function updateGoalChart(goalType, current, goal) {
    const goalToChartId = { "Follower Goal":"followerChart", "Subscription Goal":"subscriptionChart", "Bits Goal":"bitsChart", "Donation Goal":"donationChart" };
    const chartId = goalToChartId[goalType];
    const ctx = document.getElementById(chartId)?.getContext('2d');
    if (!ctx) return;

    const progress = Math.min(100, (current/goal)*100);
    const remaining = 100 - progress;

    if (!goalCharts[goalType]) {
        goalCharts[goalType] = new Chart(ctx, {
            type:'doughnut',
            data:{labels:["Progress","Remaining"], datasets:[{data:[progress,remaining], backgroundColor:["#4caf50","#ddd"]}]},
            options:{ responsive:true, maintainAspectRatio:false, plugins:{ datalabels:{ color:'white', font:{weight:'bold', size:14}, formatter:(value, context)=> Math.round(context.dataset.data[0]) + "%" } } },
            plugins:[ChartDataLabels]
        });
    } else {
        goalCharts[goalType].data.datasets[0].data = [progress, remaining];
        goalCharts[goalType].update();
    }

    if(goalType==="Follower Goal"){followerCurrent=current; followerGoal=goal;}
    if(goalType==="Subscription Goal"){subCurrent=current; subGoal=goal;}
    if(goalType==="Bits Goal"){bitsCurrent=current; bitsGoal=goal;}
    if(goalType==="Donation Goal"){donationCurrent=current; donationGoal=goal;}
}

// Update goal stats
function updateGoalStats(goalType, current, goal) {
    const goalToStatsId = { "Follower Goal":"followerStats","Subscription Goal":"subscriptionStats","Bits Goal":"bitsStats","Donation Goal":"donationStats" };
    const statsId = goalToStatsId[goalType];

    let currentFormatted=current, goalFormatted=goal;
    if(goalType==="Donation Goal") {
        currentFormatted = new Intl.NumberFormat('en-US',{style:'currency',currency:'USD'}).format(current);
        goalFormatted = new Intl.NumberFormat('en-US',{style:'currency',currency:'USD'}).format(goal);
    }

    document.getElementById(statsId).textContent = `${goalType}: ${currentFormatted} / ${goalFormatted}`;
}

// Time remaining for canvas
function getTimeRemaining() {
    const now = new Date().getTime();
    const timeLeft = targetDate - now;
    return {
        countdownDays: Math.floor(timeLeft / (1000*60*60*24)),
        countdownHours: Math.floor((timeLeft%(1000*60*60*24))/(1000*60*60)),
        countdownMinutes: Math.floor((timeLeft%(1000*60*60))/(1000*60)),
        countdownSeconds: Math.floor((timeLeft%(1000*60))/1000),
        percentage: Math.max(0,Math.min(1,1 - timeLeft / (targetDate - new Date("2025-02-18T00:00:00").getTime())))
    };
}

// Canvas drawing
function drawCameraCircle(x, y, radius, transparency) {
    ctx.save();
    ctx.globalAlpha = transparency;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI*2);
    ctx.clip();
    ctx.drawImage(cameraImage, x-radius, y-radius, radius*2, radius*2);
    ctx.restore();
    ctx.beginPath();
    ctx.arc(x, y, radius,0,Math.PI*2);
    ctx.lineWidth = 8;
    ctx.strokeStyle = '#FF0000CC';
    ctx.stroke();
}

function drawDonut(x, y, radius, width, percentage, color) {
    const endAngle = Math.PI*2*percentage - Math.PI/2;
    if(percentage>0){
        ctx.beginPath();
        ctx.arc(x,y,radius,-Math.PI/2,endAngle);
        ctx.lineWidth = width;
        ctx.strokeStyle = color;
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(x,y,radius+width/2,-Math.PI/2,endAngle);
        ctx.lineWidth=5;
        ctx.strokeStyle='#1D3ACDFF';
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(x,y,radius-width/2,-Math.PI/2,endAngle);
        ctx.lineWidth=5;
        ctx.strokeStyle='black';
        ctx.stroke();
    }
}

function drawLabelWithLine(label, x, y, radius, percentage, labelIndex, totalLabels, textColor, lineColor, borderColor){
    const padding = 10;
    const fontSize = 80;
    ctx.font = `bold ${fontSize}px Arial`;

    const textWidth = ctx.measureText(label).width;
    const labelWidth = textWidth + padding * 2;
    const labelHeight = fontSize + padding * 2;

    // stack labels vertically, but also center based on total labels
    const reversedIndex = totalLabels - labelIndex - 1;
    const labelX = 100; // left-aligned
    const labelY = 100 + reversedIndex * (labelHeight + 10);

    // FIX: Use a consistent angle around the circle
    const angle = -Math.PI/2 + Math.PI*2*((labelIndex + 0.5)/totalLabels); 
    const startX = x + radius * Math.cos(angle);
    const startY = y + radius * Math.sin(angle);

    // draw line from donut edge to label
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(labelX + labelWidth, labelY + labelHeight/2);
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = 4;
    ctx.stroke();

    // draw label border
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = 10;
    ctx.strokeRect(labelX, labelY, labelWidth, labelHeight);

    // draw label background
    ctx.fillStyle = '#0000007F';
    ctx.fillRect(labelX, labelY, labelWidth, labelHeight);

    // draw text
    ctx.fillStyle = textColor;
    ctx.textAlign = 'left';
    ctx.fillText(label, labelX + padding, labelY + fontSize + padding/2);
}


function drawAll(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawCameraCircle(centerX, centerY, cameraRadius+20, .13);

    const {countdownDays,countdownHours,countdownMinutes,countdownSeconds,percentage} = getTimeRemaining();
    const countdownText = `Retires In: ${countdownDays}d ${countdownHours}h ${countdownMinutes}m ${countdownSeconds}s`;

    let data = [
        { label:`Followers: ${followerCurrent}/${followerGoal}`, percentage:safePercent(followerCurrent,followerGoal), color:'#1D3ACDFF'},
        { label:`Subs: ${subCurrent}/${subGoal}`, percentage:safePercent(subCurrent,subGoal), color:'#1D3ACDFF'},
        { label:`Donations: $${donationCurrent}/$${donationGoal}`, percentage:safePercent(donationCurrent,donationGoal), color:'#1D3ACDFF'},
        { label:`Bits: ${bitsCurrent}/${bitsGoal}`, percentage:safePercent(bitsCurrent,bitsGoal), color:'#1D3ACDFF'},
        { label:countdownText, percentage, color:'#1D3ACDFF'}
    ];

    data.sort((a,b)=>b.percentage-a.percentage);

    data.forEach((item,index)=>drawDonut(centerX,centerY,baseRadius+index*(donutWidth+donutSpacing),donutWidth,item.percentage,item.color));
    data.forEach((item,index)=>drawLabelWithLine(item.label,centerX,centerY,baseRadius+index*(donutWidth+donutSpacing),item.percentage,index,data.length,'#FF0000CC','black','black'));

    requestAnimationFrame(drawAll);
}

// Load initial data
loadInitialData();

// Timer and goal refresh every 5 seconds
async function getUpdatedTimerData(){
    const timerData = await fetchData("https://script.google.com/macros/s/AKfycby4UKXfW68KHrWyGoRUpuPnUcTk2Eu2SyLxm3XrcYPX7qwtlWG6I02WWrckkbAgI3Af/exec?action=getTimer&timerName=Timer");
    if(timerData){
        startTime=new Date(timerData.startTime);
        endTime=new Date(timerData.endTime);
        document.getElementById("targetDateDisplay").textContent=`Target Date: ${endTime.toDateString()} ${endTime.toLocaleTimeString()}`;
        updateTimerChart();
        updateCountdown();
    }
}

function refreshDataPeriodically(){
    setInterval(async()=>{
        await getUpdatedTimerData();
        await fetchAllGoalData();
    },5000);
}

cameraImage.onload=function(){
    drawAll();
    refreshDataPeriodically();
};
</script>
</body>
</html>

