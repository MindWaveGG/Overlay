<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Timer and Goal Tracker</title>
<script src="https://cdn.jsdelivr.net"></script>
<script src="https://cdn.jsdelivr.net"></script>
<style>
    body { font-family: Arial, sans-serif; margin:0; padding:20px; background-color: transparent; }
    h1 { text-align:center; display: none; } /* Hidden for overlay cleaness */
    .container { display:flex; justify-content:space-around; flex-wrap:wrap; display: none; }
    #myCanvas { width: 100%; height: auto; }
    #errorMessage { color:red; position: fixed; top: 10px; left: 10px; }
</style>
</head>
<body>
<canvas id="myCanvas"></canvas>
<div id="errorMessage"></div>
<!-- Keeping IDs for script compatibility even if hidden -->
<div id="refreshTracker" style="display:none"></div>
<div id="targetDateDisplay" style="display:none"></div>

<script>
// --- GLOBALS ---
let initiationComplete = false;
let timers = []; 
let followerCurrent=0, followerGoal=0, subCurrent=0, subGoal=0;
let donationCurrent=0, donationGoal=0, bitsCurrent=0, bitsGoal=0;
const goalCharts = {};

const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
const canvasSize = 2200; 
canvas.width = canvasSize; 
canvas.height = canvasSize;

const centerX = canvas.width/2;
const centerY = canvas.height/2;
const cameraRadius = 670;
const red={r:255,g:0,b:0}, blue={r:0,g:0,b:255};

const cameraImage = new Image();
cameraImage.src = 'https://static-cdn.jtvnw.net';

// --- UTILITIES ---
async function fetchData(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error("Network error");
        return await response.json();
    } catch (error) {
        console.error("Fetch error:", error);
        return null;
    }
}

function lerpColor(c1,c2,t){return {r:Math.round(c1.r+(c2.r-c1.r)*t),g:Math.round(c1.g+(c2.g-c1.g)*t),b:Math.round(c1.b+(c2.b-c1.b)*t)}} 
function rgbToHex(c){return "#"+((1<<24)+(c.r<<16)+(c.g<<8)+c.b).toString(16).slice(1);}

// --- TIMER LOGIC ---
function getTimeRemaining(timer){
    const now = Date.now();
    const timeLeft = timer.endTime - now;
    const totalDuration = timer.endTime - timer.startTime;
    const percentage = Math.max(0, Math.min(1, timeLeft / totalDuration));

    return {
        countdownDays: Math.floor(timeLeft/(1000*60*60*24)),
        countdownHours: Math.floor((timeLeft%(1000*60*60*24))/(1000*60*60)),
        countdownMinutes: Math.floor((timeLeft%(1000*60*60))/(1000*60)),
        countdownSeconds: Math.floor((timeLeft%(1000*60))/1000),
        percentage
    };
}

async function removeExpiredTimers() {
    const now = Date.now();
    for (let i = timers.length - 1; i >= 0; i--) {
        if (timers[i].endTime <= now) {
            const url = `https://script.google.com/macros/s/AKfycbzCQF3jwwVF7Wy3wrY8-0JOViHOH8LJ3i42R3rDwMYkxFcAqI0lkMIE8YQWxHDEIDfD/exec?action=deltimer&timername={encodeURIComponent(timers[i].name)}`;
            fetch(url).catch(e => console.error("Del error", e));
            timers.splice(i, 1);
        }
    }
}

// --- DATA FETCHING ---
async function getUpdatedTimerData() {
    const url = "customapi.https://script.google.com/macros/s/AKfycbzCQF3jwwVF7Wy3wrY8-0JOViHOH8LJ3i42R3rDwMYkxFcAqI0lkMIE8YQWxHDEIDfD/exec?action=gettimers";
    const data = await fetchData(url);
    if(data) {
        timers = data.map(t => ({
            name: t.timerName,
            startTime: new Date(t.startDateTime).getTime(),
            endTime: new Date(t.endDateTime).getTime()
        }));
    }
}

async function fetchGoalData(goalType) {
    const url = `https://script.google.com/macros/s/AKfycbzCQF3jwwVF7Wy3wrY8-0JOViHOH8LJ3i42R3rDwMYkxFcAqI0lkMIE8YQWxHDEIDfD/exec?action=getgoal&goaltype={encodeURIComponent(goalType)}`;
    const data = await fetchData(url);
    if(data) {
        if(goalType==="Follower Goal"){ followerCurrent=data.CurrentCount; followerGoal=data.goalValue; }
        if(goalType==="Subscription Goal"){ subCurrent=data.CurrentCount; subGoal=data.goalValue; }
        if(goalType==="Bits Goal"){ bitsCurrent=data.CurrentCount; bitsGoal=data.goalValue; }
        if(goalType==="Donation Goal"){ donationCurrent=data.CurrentCount; donationGoal=data.goalValue; }
    }
}

async function fetchAllGoalData() {
    const types = ["Follower Goal","Subscription Goal","Bits Goal","Donation Goal"];
    await Promise.all(types.map(fetchGoalData));
}

// --- DRAWING FUNCTIONS ---
function drawCameraCircle(x,y,radius,alpha){
    ctx.save(); ctx.globalAlpha=alpha;
    ctx.beginPath(); ctx.arc(x,y,radius,0,Math.PI*2); ctx.clip();
    ctx.drawImage(cameraImage,x-radius,y-radius,radius*2,radius*2);
    ctx.restore();
    ctx.beginPath(); ctx.arc(x,y,radius,0,Math.PI*2); ctx.lineWidth=8; ctx.strokeStyle='#FF0000CC'; ctx.stroke();
}

function drawDonut(x, y, radius, width, percentage, color) {
    if (percentage <= 0) return;
    const startAngle = -Math.PI / 2;
    const endAngle = (Math.PI * 2 * percentage) + startAngle;
    const bW = Math.min(5, width * 0.15);

    ctx.beginPath(); ctx.arc(x, y, radius, startAngle, endAngle);
    ctx.lineWidth = width; ctx.strokeStyle = color; ctx.stroke();

    ctx.beginPath(); ctx.arc(x, y, radius + width/2, startAngle, endAngle);
    ctx.lineWidth = bW; ctx.strokeStyle = color; ctx.stroke();

    ctx.beginPath(); ctx.arc(x, y, radius - width/2, startAngle, endAngle);
    ctx.lineWidth = bW; ctx.strokeStyle = 'black'; ctx.stroke();
}

function drawLabelWithLine(label, x, y, radius, percentage, index, totalLabels, color) {
    let fontSize = 80;
    if (totalLabels > 7) fontSize = Math.max(30, 80 * (7 / totalLabels)); 
    const padding = fontSize * 0.125;
    ctx.font = `bold ${fontSize}px Arial`;
    const labelHeight = fontSize + padding * 2;
    const labelX = 100, labelY = 100 + index * (labelHeight + 10);
    const angle = -Math.PI / 2 + Math.PI * 2 * percentage;
    const startX = x + radius * Math.cos(angle), startY = y + radius * Math.sin(angle);

    ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(labelX + 200, labelY + labelHeight / 2); 
    ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.stroke();

    ctx.fillStyle = '#0000007F'; ctx.fillRect(labelX, labelY, ctx.measureText(label).width + padding*2, labelHeight);
    ctx.fillStyle = 'white'; ctx.fillText(label, labelX + padding, labelY + fontSize);
}

function drawAll(){
    if(!initiationComplete) { requestAnimationFrame(drawAll); return; }
    removeExpiredTimers();
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawCameraCircle(centerX,centerY,cameraRadius+20,0.13);

    const colorHex = rgbToHex(lerpColor(red,blue,(Math.sin(Date.now()/1000)+1)/2));

    const data=[
        {label:`Followers: ${followerCurrent}/${followerGoal}`,percentage:followerGoal?followerCurrent/followerGoal:0},
        {label:`Subs: ${subCurrent}/${subGoal}`,percentage:subGoal?subCurrent/subGoal:0},
        {label:`Donations: $${donationCurrent}/${donationGoal}`,percentage:donationGoal?donationCurrent/donationGoal:0},
        {label:`Bits: ${bitsCurrent}/${bitsGoal}`,percentage:bitsGoal?bitsCurrent/bitsGoal:0}
    ];

    timers.forEach(timer => {
        const tRem = getTimeRemaining(timer);
        data.push({
            label: `${timer.name}: ${tRem.countdownDays}d ${tRem.countdownHours}h ${tRem.countdownMinutes}m ${tRem.countdownSeconds}s`,
            percentage: tRem.percentage
        });
    });

    data.sort((a,b)=>b.percentage-a.percentage);

    let dW = 40, dS = 15;
    const maxS = (canvasSize / 2) - cameraRadius - 60;
    if (data.length > 7) {
        const unit = maxS / data.length;
        dW = unit * 0.72; dS = unit * 0.28;
    }
    const bR = cameraRadius + dS + (dW / 2) + 20;

    data.forEach((item, i) => {
        const r = bR + i * (dW + dS);
        drawDonut(centerX, centerY, r, dW, item.percentage, colorHex);
        drawLabelWithLine(item.label, centerX, centerY, r, item.percentage, i, data.length, colorHex);
    });

    requestAnimationFrame(drawAll);
}

// --- INIT ---
async function init(){
    await getUpdatedTimerData();
    await fetchAllGoalData();
    initiationComplete = true;
    setInterval(async () => {
        await getUpdatedTimerData();
        await fetchAllGoalData();
    }, 5000);
}

init();
drawAll();

</script>
</body>
</html>
